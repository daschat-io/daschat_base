{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"daschat-handsoff-base \u00b6 Base package for the development of integration modules with chat applications for the handsoff of conversations. Features \u00b6 Free software: MIT Documentation: https://daschat-io.github.io/daschat_base/ Enabling Python versions \u00b6 Install Python versions using pyenv and enable all versions to be used with tox : 1 2 3 $ pyenv install 3 .8.10 3 .9.5 $ pyenv shell 3 .8.10 3 .9.5 $ pyenv local 3 .8.10 Acknowledgements \u00b6 Cookiecutter zillionare/cookiecutter-pypackage Naereen/badges","title":"home"},{"location":"index.html#daschat-handsoff-base","text":"Base package for the development of integration modules with chat applications for the handsoff of conversations.","title":"daschat-handsoff-base"},{"location":"index.html#features","text":"Free software: MIT Documentation: https://daschat-io.github.io/daschat_base/","title":"Features"},{"location":"index.html#enabling-python-versions","text":"Install Python versions using pyenv and enable all versions to be used with tox : 1 2 3 $ pyenv install 3 .8.10 3 .9.5 $ pyenv shell 3 .8.10 3 .9.5 $ pyenv local 3 .8.10","title":"Enabling Python versions"},{"location":"index.html#acknowledgements","text":"Cookiecutter zillionare/cookiecutter-pypackage Naereen/badges","title":"Acknowledgements"},{"location":"api.html","text":"Daschat base fro modules and plugins. dc_abc_channel \u00b6 Daschat channel metaclasses This module must be used to create any channel plugin to be used with the Daschat System . Todo Write docs You have to also use sphinx.ext.todo extension Some docs about how it is made: https://realpython.com/factory-method-python/ https://medium.com/@geoffreykoh/implementing-the-factory-pattern-via-dynamic-registry-and-python-decorators-479fc1537bbe ChannelBase \u00b6 Base class for an channel plugin __init__ ( self , config , settings , data , ** kwargs ) special \u00b6 Initialize handsoff plugin Parameters: Name Type Description Default config Config Config of channel, hansdoff app, plugins, etc required settings Any Settinhs of the Daschat installation required data dict Additional data required Source code in daschat_base/dc_abc_channel.py def __init__ ( self , config : Config , settings : Any , data : dict , ** kwargs ): \"\"\"Initialize handsoff plugin Args: config (Config): Config of channel, hansdoff app, plugins, etc settings (Any): Settinhs of the Daschat installation data (dict): Additional data \"\"\" self . config : Config = config self . settings : BaseSettings = settings self . data : dict = data self . init_kwargs = kwargs self . media_bucket = f \"s3:// { settings . BUCKET_FS } \" health ( self , kwargs ) async \u00b6 Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def health ( self , kwargs ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass info ( self , kwargs ) async \u00b6 Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def info ( self , kwargs ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass register_daschat ( self , config , ** kwargs ) async \u00b6 Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def register_daschat ( self , config : ChannelConfig , ** kwargs ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass send_msg ( self , config , to_uid , messages , ** kwargs ) async \u00b6 Abstract method to send messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def send_msg ( self , config : ChannelConfig , to_uid : str , messages : List [ MessageSchema ], ** kwargs , ) -> bool : \"\"\" Abstract method to send messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass send_msg_template ( self , config , destination , template_id , params , ** kwargs ) async \u00b6 Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def send_msg_template ( self , config : ChannelConfig , destination : str , template_id : str , params : list , ** kwargs , ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass take_action ( self , method , step = '1' , ** kwargs ) async \u00b6 Method to take action based in some variables Source code in daschat_base/dc_abc_channel.py async def take_action ( self , method : str , step : str = \"1\" , ** kwargs ): \"\"\"Method to take action based in some variables\"\"\" state : dict = { \"plugin\" : self . plugin , \"module\" : self . __class__ . __module__ , \"class\" : self . __class__ . __name__ , \"assignment\" : self . _assignment , \"method\" : method , \"to_type\" : \"owner\" , \"to\" : \"\" , \"step\" : step , \"config_key\" : self . config . key , \"status_code\" : kwargs . pop ( \"status_code\" , 0 ), \"status\" : kwargs . pop ( \"status\" , \"STATUS-UNKNOW\" ), \"errors\" : [], \"kwargs\" : {}, } if \"e\" in kwargs : state [ \"errors\" ] . append ( str ( kwargs . pop ( \"e\" ))) state [ \"kwargs\" ] = kwargs if method . upper () == \"LOGIN\" : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) else : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) wallet_balance ( self , config , ** kwargs ) async \u00b6 Get channel account wallet balance Source code in daschat_base/dc_abc_channel.py @abstractmethod async def wallet_balance ( self , config : Config , ** kwargs ) -> bool : \"\"\" Get channel account wallet balance\"\"\" pass webhook ( self , data_in , ** kwargs ) async \u00b6 Abstract method to process webhook calls from channel provider Source code in daschat_base/dc_abc_channel.py @abstractmethod async def webhook ( self , data_in : Any , ** kwargs ) -> bool : \"\"\" Abstract method to process webhook calls from channel provider\"\"\" pass ChatIdTypesEnum \u00b6 Possible ways handsoff app associate chat_id with Daschat Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required WebhookTypesEnum \u00b6 Webhook types processed by this plugin Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required dc_abc_handoff \u00b6 Daschat handoff metaclasses This module must be used to create any handoff plugin to be used with the Daschat System . Todo Write docs You have to also use sphinx.ext.todo extension Some docs about how it is made: https://realpython.com/factory-method-python/ https://medium.com/@geoffreykoh/implementing-the-factory-pattern-via-dynamic-registry-and-python-decorators-479fc1537bbe ChatIdTypesEnum \u00b6 Possible ways handsoff app associate chat_id with Daschat Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required HandoffBase \u00b6 Base class for an handoff plugin __init__ ( self , config , settings , data , ** kwargs ) special \u00b6 Initialize handsoff plugin Parameters: Name Type Description Default config Config Config of channel, hansdoff app, plugins, etc required settings Any Settinhs of the Daschat installation required data dict Additional data required Source code in daschat_base/dc_abc_handoff.py def __init__ ( self , config : Config , settings : Any , data : dict , ** kwargs ): \"\"\"Initialize handsoff plugin Args: config (Config): Config of channel, hansdoff app, plugins, etc settings (Any): Settinhs of the Daschat installation data (dict): Additional data \"\"\" self . config : Config = config self . settings : BaseSettings = settings self . data : dict = data self . init_kwargs = kwargs self . media_bucket = f \"s3:// { settings . BUCKET_FS } \" info ( self , full_info = True ) async \u00b6 Get info about handsoff app Parameters: Name Type Description Default full_info bool Get full info or only test connection. Defaults to True. True Exceptions: Type Description NotImplementedError When not implemented Returns: Type Description bool Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def info ( self , full_info = True ) -> bool : \"\"\"Get info about handsoff app Args: full_info (bool, optional): Get full info or only test connection. Defaults to True. Raises: NotImplementedError: When not implemented Returns: bool: True if can get info, False otherwise \"\"\" send_msg ( self , contact , chat , messages , ** kwargs ) async \u00b6 Abstract method to send messages coming from contact to handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from contact to handoff application\"\"\" pass send_operator_msg ( self , contact , chat , messages , ** kwargs ) async \u00b6 Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_operator_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent\"\"\" pass take_action ( self , method , step = '1' , ** kwargs ) async \u00b6 Method to take action based in some variables Source code in daschat_base/dc_abc_handoff.py async def take_action ( self , method : str , step : str = \"1\" , ** kwargs ): \"\"\"Method to take action based in some variables\"\"\" state : dict = { \"plugin\" : self . plugin , \"module\" : self . __class__ . __module__ , \"class\" : self . __class__ . __name__ , \"assignment\" : self . _assignment , \"method\" : method , \"to_type\" : \"owner\" , \"to\" : \"\" , \"step\" : step , \"config_key\" : self . config . key , \"status_code\" : kwargs . pop ( \"status_code\" , 0 ), \"status\" : kwargs . pop ( \"status\" , \"STATUS-UNKNOW\" ), \"errors\" : [], \"kwargs\" : {}, } if \"e\" in kwargs : state [ \"errors\" ] . append ( str ( kwargs . pop ( \"e\" ))) state [ \"kwargs\" ] = kwargs if method . upper () == \"LOGIN\" : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) else : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) webhook ( self , data_in , ** kwargs ) async \u00b6 Abstract method to process webhook calls from handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def webhook ( self , data_in : dict , ** kwargs ) -> bool : \"\"\" Abstract method to process webhook calls from handoff application\"\"\" pass WebhookTypesEnum \u00b6 Webhook types processed by this plugin https://stackoverflow.com/questions/24487405/enum-getting-value-of-enum-on-string-conversion Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required messages \u00b6 DasChat standard messages text schemas \u00b6 Daschat base schemas. ChannelConfig pydantic-model \u00b6 api_key : ConstrainedStrValue pydantic-field \u00b6 Api key if needed app : ConstrainedStrValue pydantic-field required \u00b6 App ID channel_type : ConstrainedStrValue pydantic-field required \u00b6 Channel type endpoint : AnyHttpUrl pydantic-field required \u00b6 Channel API endpoint. Needs to be HTTPS extra : Dict [ str , Any ] pydantic-field \u00b6 Additional data for the channel plugin. from_uid : ConstrainedStrValue pydantic-field required \u00b6 Channel sender UID. password : ConstrainedStrValue pydantic-field \u00b6 Channel password if needed user : ConstrainedStrValue pydantic-field \u00b6 Channel user if needed Chat pydantic-model \u00b6 channel : ConstrainedStrValue pydantic-field required \u00b6 Channel used by this chat. channel_config : ConstrainedStrValue pydantic-field required \u00b6 Channel config key. channel_contact_uid : ConstrainedStrValue pydantic-field required \u00b6 Channel contact UID. channel_plugin : ConstrainedStrValue pydantic-field required \u00b6 Channel plugin used by this chat. channel_uid : ConstrainedStrValue pydantic-field required \u00b6 Contact from UID. contact_id : ConstrainedStrValue pydantic-field required \u00b6 The contact ID this chat call. handsoff_cid : ConstrainedStrValue pydantic-field \u00b6 Handsoff app own chat ID handsoff_data : List [ daschat_base . schemas . HandsoffDataSchema ] pydantic-field \u00b6 handsoff data received from the plugin and that need to be stored. handson : ConstrainedStrValue pydantic-field required \u00b6 Channel handson PLUGIN. handson_config : ConstrainedStrValue pydantic-field required \u00b6 Channel handson config key. id : ConstrainedStrValue pydantic-field required \u00b6 The ID of this chat. owner_id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the owner of this chat. status : ConstrainedIntValue pydantic-field required \u00b6 Chat status. subject : Dict [ str , Any ] pydantic-field required \u00b6 Chat subject. Config pydantic-model \u00b6 id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the config. key : ConstrainedStrValue pydantic-field required \u00b6 Config unique key. label : ConstrainedStrValue pydantic-field required \u00b6 This config label. owner_id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the owner of this config. status : ConstrainedIntValue pydantic-field \u00b6 Config status. value : Dict [ str , Any ] pydantic-field required \u00b6 Config value in json format. Contact pydantic-model \u00b6 channel : ConstrainedStrValue pydantic-field required \u00b6 Channel used by this contact. channel_id : ConstrainedStrValue pydantic-field required \u00b6 Contact channel ID. email : ConstrainedStrValue pydantic-field required \u00b6 Contact email. full_name : ConstrainedStrValue pydantic-field required \u00b6 Contact full name. id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the Contact call. owner_id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the owner of this Contact call. profile : Dict [ str , Any ] pydantic-field required \u00b6 Contact profile. status : ConstrainedIntValue pydantic-field required \u00b6 Contact status. CustomFields pydantic-model \u00b6 key : ConstrainedStrValue pydantic-field required \u00b6 Unique key. overwrite : bool pydantic-field required \u00b6 Overwrite existent value. value : ConstrainedStrValue pydantic-field required \u00b6 Value of the key. DispatchCallOutSchema pydantic-model \u00b6 messages : List [ daschat_base . schemas . MessageSchema ] pydantic-field \u00b6 Messages from dispatch module to be delivered by Daschat. result : ResultFieldSchema pydantic-field required \u00b6 Result of the dispatch module call. HandsoffDataSchema pydantic-model \u00b6 key : ConstrainedStrValue pydantic-field required \u00b6 Data unique key. namespace : ConstrainedStrValue pydantic-field required \u00b6 Which plugin this data belongs to. value : Dict [ str , Any ] pydantic-field required \u00b6 Data value in json format. HandsoffInfoDataSchema pydantic-model \u00b6 agents : List [ Dict [ str , Any ]] pydantic-field \u00b6 Handsoff agents. business_hours : List [ Dict [ str , Any ]] pydantic-field \u00b6 Business hours of human attendants departments : List [ Dict [ str , Any ]] pydantic-field \u00b6 Handsoff departments. version : ConstrainedStrValue pydantic-field required \u00b6 Handsoff app version. HandsoffInfoSchema pydantic-model \u00b6 data : HandsoffInfoDataSchema pydantic-field required \u00b6 Handsoff app data. status_code : ConstrainedIntValue pydantic-field \u00b6 Request status code. success : bool pydantic-field required \u00b6 Handsoff app is online. MediaMetaData pydantic-model \u00b6 height : int pydantic-field \u00b6 Height for image media. name : ConstrainedStrValue pydantic-field required \u00b6 Original media file name. path : Path pydantic-field required \u00b6 The valid absolute path of the media in the storage system src : AnyHttpUrl pydantic-field required \u00b6 The valid absolute URL of the media. Needs to be HTTPS type : ConstrainedStrValue pydantic-field required \u00b6 Media type. uid : ConstrainedStrValue pydantic-field \u00b6 Media optional UID. width : int pydantic-field \u00b6 Width for image media. MessageSchema pydantic-model \u00b6 agent_id : ConstrainedStrValue pydantic-field \u00b6 ID of the agent who wrote the message. agent_name : ConstrainedStrValue pydantic-field \u00b6 Name of the agent. content : ConstrainedStrValue pydantic-field required \u00b6 Message content. Department : ConstrainedStrValue pydantic-field \u00b6 Department associated with the message. dispatch : MessageDispatchEnum pydantic-field \u00b6 Dispatch message with this module message_type : MessageTypeEnum pydantic-field \u00b6 Message type ResultFieldSchema pydantic-model \u00b6 msg_id : ConstrainedStrValue pydantic-field \u00b6 Result message ID in Daschat. params : dict pydantic-field \u00b6 Params for the result template message. status : bool pydantic-field \u00b6 Call result status. text : ConstrainedStrValue pydantic-field \u00b6 Result text message or text template message. StateItemSchema pydantic-model \u00b6 data : Dict [ str , Any ] pydantic-field \u00b6 State saved data. id : ConstrainedStrValue pydantic-field required \u00b6 State ID value. order : ConstrainedIntValue pydantic-field \u00b6 Order in wich the plugin was executed. state : ConstrainedStrValue pydantic-field \u00b6 Current state value. types \u00b6 DasChat type definitions https://stackoverflow.com/questions/24487405/enum-getting-value-of-enum-on-string-conversion ActionToTypeEnum \u00b6 ActionToTypeEnum Actions types. MessageDispatchEnum \u00b6 MessageDispatchEnum Types that define which module of the DasChat ecosystem will process the message. See: https://medium.com/ingeniouslysimple/static-and-dynamic-dispatch-324d3dc890a3 MessageTypeEnum \u00b6 An enumeration.","title":"modules"},{"location":"api.html#daschat_base.dc_abc_channel","text":"Daschat channel metaclasses This module must be used to create any channel plugin to be used with the Daschat System . Todo Write docs You have to also use sphinx.ext.todo extension Some docs about how it is made: https://realpython.com/factory-method-python/ https://medium.com/@geoffreykoh/implementing-the-factory-pattern-via-dynamic-registry-and-python-decorators-479fc1537bbe","title":"dc_abc_channel"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase","text":"Base class for an channel plugin","title":"ChannelBase"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.__init__","text":"Initialize handsoff plugin Parameters: Name Type Description Default config Config Config of channel, hansdoff app, plugins, etc required settings Any Settinhs of the Daschat installation required data dict Additional data required Source code in daschat_base/dc_abc_channel.py def __init__ ( self , config : Config , settings : Any , data : dict , ** kwargs ): \"\"\"Initialize handsoff plugin Args: config (Config): Config of channel, hansdoff app, plugins, etc settings (Any): Settinhs of the Daschat installation data (dict): Additional data \"\"\" self . config : Config = config self . settings : BaseSettings = settings self . data : dict = data self . init_kwargs = kwargs self . media_bucket = f \"s3:// { settings . BUCKET_FS } \"","title":"__init__()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.health","text":"Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def health ( self , kwargs ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass","title":"health()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.info","text":"Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def info ( self , kwargs ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass","title":"info()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.register_daschat","text":"Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def register_daschat ( self , config : ChannelConfig , ** kwargs ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass","title":"register_daschat()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.send_msg","text":"Abstract method to send messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def send_msg ( self , config : ChannelConfig , to_uid : str , messages : List [ MessageSchema ], ** kwargs , ) -> bool : \"\"\" Abstract method to send messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass","title":"send_msg()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.send_msg_template","text":"Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact Source code in daschat_base/dc_abc_channel.py @abstractmethod async def send_msg_template ( self , config : ChannelConfig , destination : str , template_id : str , params : list , ** kwargs , ) -> bool : \"\"\" Abstract method to send template messages coming from Daschat yourself, any of it plugins/bots or handsoff app to channel contact\"\"\" pass","title":"send_msg_template()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.take_action","text":"Method to take action based in some variables Source code in daschat_base/dc_abc_channel.py async def take_action ( self , method : str , step : str = \"1\" , ** kwargs ): \"\"\"Method to take action based in some variables\"\"\" state : dict = { \"plugin\" : self . plugin , \"module\" : self . __class__ . __module__ , \"class\" : self . __class__ . __name__ , \"assignment\" : self . _assignment , \"method\" : method , \"to_type\" : \"owner\" , \"to\" : \"\" , \"step\" : step , \"config_key\" : self . config . key , \"status_code\" : kwargs . pop ( \"status_code\" , 0 ), \"status\" : kwargs . pop ( \"status\" , \"STATUS-UNKNOW\" ), \"errors\" : [], \"kwargs\" : {}, } if \"e\" in kwargs : state [ \"errors\" ] . append ( str ( kwargs . pop ( \"e\" ))) state [ \"kwargs\" ] = kwargs if method . upper () == \"LOGIN\" : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) else : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state )","title":"take_action()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.wallet_balance","text":"Get channel account wallet balance Source code in daschat_base/dc_abc_channel.py @abstractmethod async def wallet_balance ( self , config : Config , ** kwargs ) -> bool : \"\"\" Get channel account wallet balance\"\"\" pass","title":"wallet_balance()"},{"location":"api.html#daschat_base.dc_abc_channel.ChannelBase.webhook","text":"Abstract method to process webhook calls from channel provider Source code in daschat_base/dc_abc_channel.py @abstractmethod async def webhook ( self , data_in : Any , ** kwargs ) -> bool : \"\"\" Abstract method to process webhook calls from channel provider\"\"\" pass","title":"webhook()"},{"location":"api.html#daschat_base.dc_abc_channel.ChatIdTypesEnum","text":"Possible ways handsoff app associate chat_id with Daschat Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required","title":"ChatIdTypesEnum"},{"location":"api.html#daschat_base.dc_abc_channel.WebhookTypesEnum","text":"Webhook types processed by this plugin Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required","title":"WebhookTypesEnum"},{"location":"api.html#daschat_base.dc_abc_handoff","text":"Daschat handoff metaclasses This module must be used to create any handoff plugin to be used with the Daschat System . Todo Write docs You have to also use sphinx.ext.todo extension Some docs about how it is made: https://realpython.com/factory-method-python/ https://medium.com/@geoffreykoh/implementing-the-factory-pattern-via-dynamic-registry-and-python-decorators-479fc1537bbe","title":"dc_abc_handoff"},{"location":"api.html#daschat_base.dc_abc_handoff.ChatIdTypesEnum","text":"Possible ways handsoff app associate chat_id with Daschat Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required","title":"ChatIdTypesEnum"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase","text":"Base class for an handoff plugin","title":"HandoffBase"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.__init__","text":"Initialize handsoff plugin Parameters: Name Type Description Default config Config Config of channel, hansdoff app, plugins, etc required settings Any Settinhs of the Daschat installation required data dict Additional data required Source code in daschat_base/dc_abc_handoff.py def __init__ ( self , config : Config , settings : Any , data : dict , ** kwargs ): \"\"\"Initialize handsoff plugin Args: config (Config): Config of channel, hansdoff app, plugins, etc settings (Any): Settinhs of the Daschat installation data (dict): Additional data \"\"\" self . config : Config = config self . settings : BaseSettings = settings self . data : dict = data self . init_kwargs = kwargs self . media_bucket = f \"s3:// { settings . BUCKET_FS } \"","title":"__init__()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.info","text":"Get info about handsoff app Parameters: Name Type Description Default full_info bool Get full info or only test connection. Defaults to True. True Exceptions: Type Description NotImplementedError When not implemented Returns: Type Description bool Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def info ( self , full_info = True ) -> bool : \"\"\"Get info about handsoff app Args: full_info (bool, optional): Get full info or only test connection. Defaults to True. Raises: NotImplementedError: When not implemented Returns: bool: True if can get info, False otherwise \"\"\"","title":"info()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.send_msg","text":"Abstract method to send messages coming from contact to handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from contact to handoff application\"\"\" pass","title":"send_msg()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.send_operator_msg","text":"Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_operator_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent\"\"\" pass","title":"send_operator_msg()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.take_action","text":"Method to take action based in some variables Source code in daschat_base/dc_abc_handoff.py async def take_action ( self , method : str , step : str = \"1\" , ** kwargs ): \"\"\"Method to take action based in some variables\"\"\" state : dict = { \"plugin\" : self . plugin , \"module\" : self . __class__ . __module__ , \"class\" : self . __class__ . __name__ , \"assignment\" : self . _assignment , \"method\" : method , \"to_type\" : \"owner\" , \"to\" : \"\" , \"step\" : step , \"config_key\" : self . config . key , \"status_code\" : kwargs . pop ( \"status_code\" , 0 ), \"status\" : kwargs . pop ( \"status\" , \"STATUS-UNKNOW\" ), \"errors\" : [], \"kwargs\" : {}, } if \"e\" in kwargs : state [ \"errors\" ] . append ( str ( kwargs . pop ( \"e\" ))) state [ \"kwargs\" ] = kwargs if method . upper () == \"LOGIN\" : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) else : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state )","title":"take_action()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.webhook","text":"Abstract method to process webhook calls from handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def webhook ( self , data_in : dict , ** kwargs ) -> bool : \"\"\" Abstract method to process webhook calls from handoff application\"\"\" pass","title":"webhook()"},{"location":"api.html#daschat_base.dc_abc_handoff.WebhookTypesEnum","text":"Webhook types processed by this plugin https://stackoverflow.com/questions/24487405/enum-getting-value-of-enum-on-string-conversion Parameters: Name Type Description Default int [type] [description] required Enum [type] [description] required","title":"WebhookTypesEnum"},{"location":"api.html#daschat_base.messages","text":"DasChat standard messages text","title":"messages"},{"location":"api.html#daschat_base.schemas","text":"Daschat base schemas.","title":"schemas"},{"location":"api.html#daschat_base.schemas.ChannelConfig","text":"","title":"ChannelConfig"},{"location":"api.html#daschat_base.schemas.ChannelConfig.api_key","text":"Api key if needed","title":"api_key"},{"location":"api.html#daschat_base.schemas.ChannelConfig.app","text":"App ID","title":"app"},{"location":"api.html#daschat_base.schemas.ChannelConfig.channel_type","text":"Channel type","title":"channel_type"},{"location":"api.html#daschat_base.schemas.ChannelConfig.endpoint","text":"Channel API endpoint. Needs to be HTTPS","title":"endpoint"},{"location":"api.html#daschat_base.schemas.ChannelConfig.extra","text":"Additional data for the channel plugin.","title":"extra"},{"location":"api.html#daschat_base.schemas.ChannelConfig.from_uid","text":"Channel sender UID.","title":"from_uid"},{"location":"api.html#daschat_base.schemas.ChannelConfig.password","text":"Channel password if needed","title":"password"},{"location":"api.html#daschat_base.schemas.ChannelConfig.user","text":"Channel user if needed","title":"user"},{"location":"api.html#daschat_base.schemas.Chat","text":"","title":"Chat"},{"location":"api.html#daschat_base.schemas.Chat.channel","text":"Channel used by this chat.","title":"channel"},{"location":"api.html#daschat_base.schemas.Chat.channel_config","text":"Channel config key.","title":"channel_config"},{"location":"api.html#daschat_base.schemas.Chat.channel_contact_uid","text":"Channel contact UID.","title":"channel_contact_uid"},{"location":"api.html#daschat_base.schemas.Chat.channel_plugin","text":"Channel plugin used by this chat.","title":"channel_plugin"},{"location":"api.html#daschat_base.schemas.Chat.channel_uid","text":"Contact from UID.","title":"channel_uid"},{"location":"api.html#daschat_base.schemas.Chat.contact_id","text":"The contact ID this chat call.","title":"contact_id"},{"location":"api.html#daschat_base.schemas.Chat.handsoff_cid","text":"Handsoff app own chat ID","title":"handsoff_cid"},{"location":"api.html#daschat_base.schemas.Chat.handsoff_data","text":"handsoff data received from the plugin and that need to be stored.","title":"handsoff_data"},{"location":"api.html#daschat_base.schemas.Chat.handson","text":"Channel handson PLUGIN.","title":"handson"},{"location":"api.html#daschat_base.schemas.Chat.handson_config","text":"Channel handson config key.","title":"handson_config"},{"location":"api.html#daschat_base.schemas.Chat.id","text":"The ID of this chat.","title":"id"},{"location":"api.html#daschat_base.schemas.Chat.owner_id","text":"The ID of the owner of this chat.","title":"owner_id"},{"location":"api.html#daschat_base.schemas.Chat.status","text":"Chat status.","title":"status"},{"location":"api.html#daschat_base.schemas.Chat.subject","text":"Chat subject.","title":"subject"},{"location":"api.html#daschat_base.schemas.Config","text":"","title":"Config"},{"location":"api.html#daschat_base.schemas.Config.id","text":"The ID of the config.","title":"id"},{"location":"api.html#daschat_base.schemas.Config.key","text":"Config unique key.","title":"key"},{"location":"api.html#daschat_base.schemas.Config.label","text":"This config label.","title":"label"},{"location":"api.html#daschat_base.schemas.Config.owner_id","text":"The ID of the owner of this config.","title":"owner_id"},{"location":"api.html#daschat_base.schemas.Config.status","text":"Config status.","title":"status"},{"location":"api.html#daschat_base.schemas.Config.value","text":"Config value in json format.","title":"value"},{"location":"api.html#daschat_base.schemas.Contact","text":"","title":"Contact"},{"location":"api.html#daschat_base.schemas.Contact.channel","text":"Channel used by this contact.","title":"channel"},{"location":"api.html#daschat_base.schemas.Contact.channel_id","text":"Contact channel ID.","title":"channel_id"},{"location":"api.html#daschat_base.schemas.Contact.email","text":"Contact email.","title":"email"},{"location":"api.html#daschat_base.schemas.Contact.full_name","text":"Contact full name.","title":"full_name"},{"location":"api.html#daschat_base.schemas.Contact.id","text":"The ID of the Contact call.","title":"id"},{"location":"api.html#daschat_base.schemas.Contact.owner_id","text":"The ID of the owner of this Contact call.","title":"owner_id"},{"location":"api.html#daschat_base.schemas.Contact.profile","text":"Contact profile.","title":"profile"},{"location":"api.html#daschat_base.schemas.Contact.status","text":"Contact status.","title":"status"},{"location":"api.html#daschat_base.schemas.CustomFields","text":"","title":"CustomFields"},{"location":"api.html#daschat_base.schemas.CustomFields.key","text":"Unique key.","title":"key"},{"location":"api.html#daschat_base.schemas.CustomFields.overwrite","text":"Overwrite existent value.","title":"overwrite"},{"location":"api.html#daschat_base.schemas.CustomFields.value","text":"Value of the key.","title":"value"},{"location":"api.html#daschat_base.schemas.DispatchCallOutSchema","text":"","title":"DispatchCallOutSchema"},{"location":"api.html#daschat_base.schemas.DispatchCallOutSchema.messages","text":"Messages from dispatch module to be delivered by Daschat.","title":"messages"},{"location":"api.html#daschat_base.schemas.DispatchCallOutSchema.result","text":"Result of the dispatch module call.","title":"result"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema","text":"","title":"HandsoffDataSchema"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema.key","text":"Data unique key.","title":"key"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema.namespace","text":"Which plugin this data belongs to.","title":"namespace"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema.value","text":"Data value in json format.","title":"value"},{"location":"api.html#daschat_base.schemas.HandsoffInfoDataSchema","text":"","title":"HandsoffInfoDataSchema"},{"location":"api.html#daschat_base.schemas.HandsoffInfoDataSchema.agents","text":"Handsoff agents.","title":"agents"},{"location":"api.html#daschat_base.schemas.HandsoffInfoDataSchema.business_hours","text":"Business hours of human attendants","title":"business_hours"},{"location":"api.html#daschat_base.schemas.HandsoffInfoDataSchema.departments","text":"Handsoff departments.","title":"departments"},{"location":"api.html#daschat_base.schemas.HandsoffInfoDataSchema.version","text":"Handsoff app version.","title":"version"},{"location":"api.html#daschat_base.schemas.HandsoffInfoSchema","text":"","title":"HandsoffInfoSchema"},{"location":"api.html#daschat_base.schemas.HandsoffInfoSchema.data","text":"Handsoff app data.","title":"data"},{"location":"api.html#daschat_base.schemas.HandsoffInfoSchema.status_code","text":"Request status code.","title":"status_code"},{"location":"api.html#daschat_base.schemas.HandsoffInfoSchema.success","text":"Handsoff app is online.","title":"success"},{"location":"api.html#daschat_base.schemas.MediaMetaData","text":"","title":"MediaMetaData"},{"location":"api.html#daschat_base.schemas.MediaMetaData.height","text":"Height for image media.","title":"height"},{"location":"api.html#daschat_base.schemas.MediaMetaData.name","text":"Original media file name.","title":"name"},{"location":"api.html#daschat_base.schemas.MediaMetaData.path","text":"The valid absolute path of the media in the storage system","title":"path"},{"location":"api.html#daschat_base.schemas.MediaMetaData.src","text":"The valid absolute URL of the media. Needs to be HTTPS","title":"src"},{"location":"api.html#daschat_base.schemas.MediaMetaData.type","text":"Media type.","title":"type"},{"location":"api.html#daschat_base.schemas.MediaMetaData.uid","text":"Media optional UID.","title":"uid"},{"location":"api.html#daschat_base.schemas.MediaMetaData.width","text":"Width for image media.","title":"width"},{"location":"api.html#daschat_base.schemas.MessageSchema","text":"","title":"MessageSchema"},{"location":"api.html#daschat_base.schemas.MessageSchema.agent_id","text":"ID of the agent who wrote the message.","title":"agent_id"},{"location":"api.html#daschat_base.schemas.MessageSchema.agent_name","text":"Name of the agent.","title":"agent_name"},{"location":"api.html#daschat_base.schemas.MessageSchema.content","text":"Message content.","title":"content"},{"location":"api.html#daschat_base.schemas.MessageSchema.Department","text":"Department associated with the message.","title":"Department"},{"location":"api.html#daschat_base.schemas.MessageSchema.dispatch","text":"Dispatch message with this module","title":"dispatch"},{"location":"api.html#daschat_base.schemas.MessageSchema.message_type","text":"Message type","title":"message_type"},{"location":"api.html#daschat_base.schemas.ResultFieldSchema","text":"","title":"ResultFieldSchema"},{"location":"api.html#daschat_base.schemas.ResultFieldSchema.msg_id","text":"Result message ID in Daschat.","title":"msg_id"},{"location":"api.html#daschat_base.schemas.ResultFieldSchema.params","text":"Params for the result template message.","title":"params"},{"location":"api.html#daschat_base.schemas.ResultFieldSchema.status","text":"Call result status.","title":"status"},{"location":"api.html#daschat_base.schemas.ResultFieldSchema.text","text":"Result text message or text template message.","title":"text"},{"location":"api.html#daschat_base.schemas.StateItemSchema","text":"","title":"StateItemSchema"},{"location":"api.html#daschat_base.schemas.StateItemSchema.data","text":"State saved data.","title":"data"},{"location":"api.html#daschat_base.schemas.StateItemSchema.id","text":"State ID value.","title":"id"},{"location":"api.html#daschat_base.schemas.StateItemSchema.order","text":"Order in wich the plugin was executed.","title":"order"},{"location":"api.html#daschat_base.schemas.StateItemSchema.state","text":"Current state value.","title":"state"},{"location":"api.html#daschat_base.types","text":"DasChat type definitions https://stackoverflow.com/questions/24487405/enum-getting-value-of-enum-on-string-conversion","title":"types"},{"location":"api.html#daschat_base.types.ActionToTypeEnum","text":"ActionToTypeEnum Actions types.","title":"ActionToTypeEnum"},{"location":"api.html#daschat_base.types.MessageDispatchEnum","text":"MessageDispatchEnum Types that define which module of the DasChat ecosystem will process the message. See: https://medium.com/ingeniouslysimple/static-and-dynamic-dispatch-324d3dc890a3","title":"MessageDispatchEnum"},{"location":"api.html#daschat_base.types.MessageTypeEnum","text":"An enumeration.","title":"MessageTypeEnum"},{"location":"authors.html","text":"Credits \u00b6 Development Lead \u00b6 Abner G Jacobsen abner@apoana.com.br Contributors \u00b6 None yet. Why not be the first?","title":"authors"},{"location":"authors.html#credits","text":"","title":"Credits"},{"location":"authors.html#development-lead","text":"Abner G Jacobsen abner@apoana.com.br","title":"Development Lead"},{"location":"authors.html#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing.html","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/daschat-io/daschat_base/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Base package for the development of integration modules with chat applications for the handsoff of conversations. could always use more documentation, whether as part of the official Base package for the development of integration modules with chat applications for the handsoff of conversations. docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/daschat-io/daschat_base/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up daschat_base for local development. Fork the daschat_base repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/daschat_base.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/daschat-io/daschat_base/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_daschat_base ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes for version are committed in pyproject.toml and test_daschat_handsoff_base.py (including an entry in HISTORY.md). Then run: 1 2 3 $ git tag v0.7.0 $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing.html#report-bugs","text":"Report bugs at https://github.com/daschat-io/daschat_base/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing.html#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing.html#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing.html#write-documentation","text":"Base package for the development of integration modules with chat applications for the handsoff of conversations. could always use more documentation, whether as part of the official Base package for the development of integration modules with chat applications for the handsoff of conversations. docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing.html#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/daschat-io/daschat_base/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up daschat_base for local development. Fork the daschat_base repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/daschat_base.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/daschat-io/daschat_base/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing.html#tips","text":"1 $ pytest tests.test_daschat_base ```To run a subset of tests.","title":"Tips```"},{"location":"contributing.html#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes for version are committed in pyproject.toml and test_daschat_handsoff_base.py (including an entry in HISTORY.md). Then run: 1 2 3 $ git tag v0.7.0 $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history.html","text":"History \u00b6 0.13.0 (2021-10-25) \u00b6 Add or update types \u00b6 Added ResultFieldSchema and DispatchCallOutSchema schemas. They will be used to standardize the return of API calls and modules. Created messages.py to hold all text messages generated by daschat. Added the department field to the MessageSchema schema. In the future it will allow to register in the log who wrote the message sent to the contact. Changed max size of agent_id , agent_name fields in the MessageSchema schema. 0.12.1 (2021-10-23) \u00b6 Add or update types \u00b6 Created version.py for package version info. Created types.py to be the global type and class definition center. Added new enum type MessageDispatchEnum in WebhookTypesEnumtypes.py . Added the dispatch field to the MessageSchema schema. In the future it will allow to select wich module of DasChat will process the message. 0.12.0 (2021-10-23) \u00b6 Add or update types \u00b6 Added the agent_id , agent_name fields to the MessageSchema schema. In the future it will allow to register in the log who wrote the message sent to the contact. Added new webhook type CHAT_FORWARDED in WebhookTypesEnum for when the chat is transferred to another agent or bot. Work in progress \u00b6 Added module dc_abc_channel.py with abstract class ChannelBase for channels plugins. 0.11.1 (2021-10-10) \u00b6 Fix typos \u00b6 Proprerty info has same name as info method. Changed proprerty name to info_data . 0.11.0 (2021-10-13) \u00b6 New features \u00b6 Breaking changes \u00b6 Added info method to HandoffBase class. 0.10.1 (2021-10-10) \u00b6 Fix typos \u00b6 Fixed variable names. Addittional doctrings. 0.10.0 (2021-10-09) \u00b6 Added property chat_id_type to handle handsoff apps, like Rocketchat, that not allow use of the chat_id generated by Daschat 0.9.0 (2021-10-05) \u00b6 Added columns for handsoff app data and chat id control 0.8.0 (2021-07-21) \u00b6 Added webhook enum type for CHAT_TAKEN Docs corrections in how to deploy official version 0.7.0 (2021-07-20) \u00b6 Added CHAT_SESSION as webhook type enum. 0.4.0 (2021-06-28) \u00b6 First release on PyPI.","title":"history"},{"location":"history.html#history","text":"","title":"History"},{"location":"history.html#0130-2021-10-25","text":"","title":"0.13.0 (2021-10-25)"},{"location":"history.html#add-or-update-types","text":"Added ResultFieldSchema and DispatchCallOutSchema schemas. They will be used to standardize the return of API calls and modules. Created messages.py to hold all text messages generated by daschat. Added the department field to the MessageSchema schema. In the future it will allow to register in the log who wrote the message sent to the contact. Changed max size of agent_id , agent_name fields in the MessageSchema schema.","title":"Add or update types"},{"location":"history.html#0121-2021-10-23","text":"","title":"0.12.1 (2021-10-23)"},{"location":"history.html#add-or-update-types_1","text":"Created version.py for package version info. Created types.py to be the global type and class definition center. Added new enum type MessageDispatchEnum in WebhookTypesEnumtypes.py . Added the dispatch field to the MessageSchema schema. In the future it will allow to select wich module of DasChat will process the message.","title":"Add or update types"},{"location":"history.html#0120-2021-10-23","text":"","title":"0.12.0 (2021-10-23)"},{"location":"history.html#add-or-update-types_2","text":"Added the agent_id , agent_name fields to the MessageSchema schema. In the future it will allow to register in the log who wrote the message sent to the contact. Added new webhook type CHAT_FORWARDED in WebhookTypesEnum for when the chat is transferred to another agent or bot.","title":"Add or update types"},{"location":"history.html#work-in-progress","text":"Added module dc_abc_channel.py with abstract class ChannelBase for channels plugins.","title":"Work in progress"},{"location":"history.html#0111-2021-10-10","text":"","title":"0.11.1 (2021-10-10)"},{"location":"history.html#fix-typos","text":"Proprerty info has same name as info method. Changed proprerty name to info_data .","title":"Fix typos"},{"location":"history.html#0110-2021-10-13","text":"","title":"0.11.0 (2021-10-13)"},{"location":"history.html#new-features","text":"","title":"New features"},{"location":"history.html#breaking-changes","text":"Added info method to HandoffBase class.","title":"Breaking changes"},{"location":"history.html#0101-2021-10-10","text":"","title":"0.10.1 (2021-10-10)"},{"location":"history.html#fix-typos_1","text":"Fixed variable names. Addittional doctrings.","title":"Fix typos"},{"location":"history.html#0100-2021-10-09","text":"Added property chat_id_type to handle handsoff apps, like Rocketchat, that not allow use of the chat_id generated by Daschat","title":"0.10.0 (2021-10-09)"},{"location":"history.html#090-2021-10-05","text":"Added columns for handsoff app data and chat id control","title":"0.9.0 (2021-10-05)"},{"location":"history.html#080-2021-07-21","text":"Added webhook enum type for CHAT_TAKEN Docs corrections in how to deploy official version","title":"0.8.0 (2021-07-21)"},{"location":"history.html#070-2021-07-20","text":"Added CHAT_SESSION as webhook type enum.","title":"0.7.0 (2021-07-20)"},{"location":"history.html#040-2021-06-28","text":"First release on PyPI.","title":"0.4.0 (2021-06-28)"},{"location":"installation.html","text":"Installation \u00b6 Stable release \u00b6 To install Base package for the development of integration modules with chat applications for the handsoff of conversations., run this command in your terminal: 1 $ pip install daschat_base This is the preferred method to install Base package for the development of integration modules with chat applications for the handsoff of conversations., as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Base package for the development of integration modules with chat applications for the handsoff of conversations. can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/daschat-io/daschat_base Or download the tarball : 1 $ curl -OJL https://github.com/daschat-io/daschat_base/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"installation"},{"location":"installation.html#installation","text":"","title":"Installation"},{"location":"installation.html#stable-release","text":"To install Base package for the development of integration modules with chat applications for the handsoff of conversations., run this command in your terminal: 1 $ pip install daschat_base This is the preferred method to install Base package for the development of integration modules with chat applications for the handsoff of conversations., as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation.html#from-source","text":"The source for Base package for the development of integration modules with chat applications for the handsoff of conversations. can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/daschat-io/daschat_base Or download the tarball : 1 $ curl -OJL https://github.com/daschat-io/daschat_base/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage.html","text":"Usage \u00b6 To use Base package for the development of integration modules with chat applications for the handsoff of conversations. in a project 1 from daschat_base imports schemas","title":"usage"},{"location":"usage.html#usage","text":"To use Base package for the development of integration modules with chat applications for the handsoff of conversations. in a project 1 from daschat_base imports schemas","title":"Usage"}]}