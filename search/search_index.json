{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"daschat-handsoff-base \u00b6 Base package for the development of integration modules with chat applications for the handsoff of conversations. Features \u00b6 Free software: MIT Documentation: https://daschat-io.github.io/daschat_base/ Enabling Python versions \u00b6 Install Python versions using pyenv and enable all versions to be used with tox : 1 2 3 $ pyenv install 3 .8.10 3 .9.5 $ pyenv shell 3 .8.10 3 .9.5 $ pyenv local 3 .8.10 Acknowledgements \u00b6 Cookiecutter zillionare/cookiecutter-pypackage Naereen/badges","title":"home"},{"location":"index.html#daschat-handsoff-base","text":"Base package for the development of integration modules with chat applications for the handsoff of conversations.","title":"daschat-handsoff-base"},{"location":"index.html#features","text":"Free software: MIT Documentation: https://daschat-io.github.io/daschat_base/","title":"Features"},{"location":"index.html#enabling-python-versions","text":"Install Python versions using pyenv and enable all versions to be used with tox : 1 2 3 $ pyenv install 3 .8.10 3 .9.5 $ pyenv shell 3 .8.10 3 .9.5 $ pyenv local 3 .8.10","title":"Enabling Python versions"},{"location":"index.html#acknowledgements","text":"Cookiecutter zillionare/cookiecutter-pypackage Naereen/badges","title":"Acknowledgements"},{"location":"api.html","text":"Daschat base fro modules and plugins. dc_abc_handoff \u00b6 Daschat handoff metaclasses This module must be used to create any handoff plugin to be used with the Daschat System . Todo Write docs You have to also use sphinx.ext.todo extension Some docs about how it is made: https://realpython.com/factory-method-python/ https://medium.com/@geoffreykoh/implementing-the-factory-pattern-via-dynamic-registry-and-python-decorators-479fc1537bbe HandoffBase \u00b6 Base class for an handoff plugin __init__ ( self , config , settings , data , ** kwargs ) special \u00b6 Constructor Source code in daschat_base/dc_abc_handoff.py def __init__ ( self , config : Config , settings : Any , data : dict , ** kwargs ): \"\"\"Constructor\"\"\" self . config : Config = config self . settings : BaseSettings = settings self . data : dict = data self . init_kwargs = kwargs self . media_bucket = f \"s3:// { settings . BUCKET_FS } \" send_msg ( self , contact , chat , messages , ** kwargs ) async \u00b6 Abstract method to send messages coming from contact to handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from contact to handoff application\"\"\" pass send_operator_msg ( self , contact , chat , messages , ** kwargs ) async \u00b6 Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_operator_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent\"\"\" pass take_action ( self , method , step = '1' , ** kwargs ) async \u00b6 Method to take action based in some variables Source code in daschat_base/dc_abc_handoff.py async def take_action ( self , method : str , step : str = \"1\" , ** kwargs ): \"\"\"Method to take action based in some variables\"\"\" state : dict = { \"plugin\" : self . plugin , \"module\" : self . __class__ . __module__ , \"class\" : self . __class__ . __name__ , \"assignment\" : self . _assignment , \"method\" : method , \"to_type\" : \"owner\" , \"to\" : \"\" , \"step\" : step , \"config_key\" : self . config . key , \"status_code\" : kwargs . pop ( \"status_code\" , 0 ), \"status\" : kwargs . pop ( \"status\" , \"STATUS-UNKNOW\" ), \"errors\" : [], \"kwargs\" : {}, } if \"e\" in kwargs : state [ \"errors\" ] . append ( str ( kwargs . pop ( \"e\" ))) state [ \"kwargs\" ] = kwargs if method . upper () == \"LOGIN\" : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) else : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) webhook ( self , data_in , ** kwargs ) async \u00b6 Abstract method to process webhook calls from handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def webhook ( self , data_in : dict , ** kwargs ) -> bool : \"\"\" Abstract method to process webhook calls from handoff application\"\"\" pass WebhookTypesEnum \u00b6 An enumeration. schemas \u00b6 Daschat base schemas. ActionToTypeEnum \u00b6 ActionToTypeEnum Actions types. Chat pydantic-model \u00b6 channel : ConstrainedStrValue pydantic-field required \u00b6 Channel used by this chat. channel_config : ConstrainedStrValue pydantic-field required \u00b6 Channel config key. channel_contact_uid : ConstrainedStrValue pydantic-field required \u00b6 Channel contact UID. channel_plugin : ConstrainedStrValue pydantic-field required \u00b6 Channel plugin used by this chat. channel_uid : ConstrainedStrValue pydantic-field required \u00b6 Contact from UID. contact_id : ConstrainedStrValue pydantic-field required \u00b6 The contact ID this chat call. handsoff_cid : ConstrainedStrValue pydantic-field \u00b6 Handsoff app own chat ID handsoff_data : List [ daschat_base . schemas . HandsoffDataSchema ] pydantic-field \u00b6 handsoff data received from the plugin and that need to be stored. handson : ConstrainedStrValue pydantic-field required \u00b6 Channel handson PLUGIN. handson_config : ConstrainedStrValue pydantic-field required \u00b6 Channel handson config key. id : ConstrainedStrValue pydantic-field required \u00b6 The ID of this chat. owner_id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the owner of this chat. status : ConstrainedIntValue pydantic-field required \u00b6 Chat status. subject : Dict [ str , Any ] pydantic-field required \u00b6 Chat subject. Config pydantic-model \u00b6 id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the config. key : ConstrainedStrValue pydantic-field required \u00b6 Config unique key. label : ConstrainedStrValue pydantic-field required \u00b6 This config label. owner_id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the owner of this config. status : ConstrainedIntValue pydantic-field \u00b6 Config status. value : Dict [ str , Any ] pydantic-field required \u00b6 Config value in json format. Contact pydantic-model \u00b6 channel : ConstrainedStrValue pydantic-field required \u00b6 Channel used by this contact. channel_id : ConstrainedStrValue pydantic-field required \u00b6 Contact channel ID. email : ConstrainedStrValue pydantic-field required \u00b6 Contact email. full_name : ConstrainedStrValue pydantic-field required \u00b6 Contact full name. id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the Contact call. owner_id : ConstrainedStrValue pydantic-field required \u00b6 The ID of the owner of this Contact call. profile : Dict [ str , Any ] pydantic-field required \u00b6 Contact profile. status : ConstrainedIntValue pydantic-field required \u00b6 Contact status. CustomFields pydantic-model \u00b6 key : ConstrainedStrValue pydantic-field required \u00b6 Unique key. overwrite : bool pydantic-field required \u00b6 Overwrite existent value. value : ConstrainedStrValue pydantic-field required \u00b6 Value of the key. HandsoffDataSchema pydantic-model \u00b6 key : ConstrainedStrValue pydantic-field required \u00b6 Data unique key. namespace : ConstrainedStrValue pydantic-field required \u00b6 Which plugin this data belongs to. value : Dict [ str , Any ] pydantic-field required \u00b6 Data value in json format. MediaMetaData pydantic-model \u00b6 height : int pydantic-field \u00b6 Height for image media. name : ConstrainedStrValue pydantic-field required \u00b6 Original media file name. path : Path pydantic-field required \u00b6 The valid absolute path of the media in the storage system src : AnyHttpUrl pydantic-field required \u00b6 The valid absolute URL of the media. Needs to be HTTPS type : ConstrainedStrValue pydantic-field required \u00b6 Media type. uid : ConstrainedStrValue pydantic-field \u00b6 Media optional UID. width : int pydantic-field \u00b6 Width for image media. MessageSchema pydantic-model \u00b6 content : ConstrainedStrValue pydantic-field required \u00b6 Message content. message_type : MessageTypeEnum pydantic-field \u00b6 Message type. MessageTypeEnum \u00b6 An enumeration. StateItemSchema pydantic-model \u00b6 data : Dict [ str , Any ] pydantic-field \u00b6 State saved data. id : ConstrainedStrValue pydantic-field required \u00b6 State ID value. order : ConstrainedIntValue pydantic-field \u00b6 Order in wich the plugin was executed. state : ConstrainedStrValue pydantic-field \u00b6 Current state value.","title":"modules"},{"location":"api.html#daschat_base.dc_abc_handoff","text":"Daschat handoff metaclasses This module must be used to create any handoff plugin to be used with the Daschat System . Todo Write docs You have to also use sphinx.ext.todo extension Some docs about how it is made: https://realpython.com/factory-method-python/ https://medium.com/@geoffreykoh/implementing-the-factory-pattern-via-dynamic-registry-and-python-decorators-479fc1537bbe","title":"dc_abc_handoff"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase","text":"Base class for an handoff plugin","title":"HandoffBase"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.__init__","text":"Constructor Source code in daschat_base/dc_abc_handoff.py def __init__ ( self , config : Config , settings : Any , data : dict , ** kwargs ): \"\"\"Constructor\"\"\" self . config : Config = config self . settings : BaseSettings = settings self . data : dict = data self . init_kwargs = kwargs self . media_bucket = f \"s3:// { settings . BUCKET_FS } \"","title":"__init__()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.send_msg","text":"Abstract method to send messages coming from contact to handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from contact to handoff application\"\"\" pass","title":"send_msg()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.send_operator_msg","text":"Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def send_operator_msg ( self , contact : Contact , chat : Chat , messages : List [ MessageSchema ], ** kwargs ) -> bool : \"\"\" Abstract method to send messages coming from Daschat yourself or any of it plugins/bots to handoff application chat agent\"\"\" pass","title":"send_operator_msg()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.take_action","text":"Method to take action based in some variables Source code in daschat_base/dc_abc_handoff.py async def take_action ( self , method : str , step : str = \"1\" , ** kwargs ): \"\"\"Method to take action based in some variables\"\"\" state : dict = { \"plugin\" : self . plugin , \"module\" : self . __class__ . __module__ , \"class\" : self . __class__ . __name__ , \"assignment\" : self . _assignment , \"method\" : method , \"to_type\" : \"owner\" , \"to\" : \"\" , \"step\" : step , \"config_key\" : self . config . key , \"status_code\" : kwargs . pop ( \"status_code\" , 0 ), \"status\" : kwargs . pop ( \"status\" , \"STATUS-UNKNOW\" ), \"errors\" : [], \"kwargs\" : {}, } if \"e\" in kwargs : state [ \"errors\" ] . append ( str ( kwargs . pop ( \"e\" ))) state [ \"kwargs\" ] = kwargs if method . upper () == \"LOGIN\" : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state ) else : # Probably configuration error, notify the owner if len ( state [ \"errors\" ]) == 0 : logger . warning ( json . dumps ( state )) # Probably programming error, notify DevOps else : state [ \"to_type\" ] = ActionToTypeEnum . devops logger . error ( json . dumps ( state )) # Save action self . _actions . append ( state )","title":"take_action()"},{"location":"api.html#daschat_base.dc_abc_handoff.HandoffBase.webhook","text":"Abstract method to process webhook calls from handoff application Source code in daschat_base/dc_abc_handoff.py @abstractmethod async def webhook ( self , data_in : dict , ** kwargs ) -> bool : \"\"\" Abstract method to process webhook calls from handoff application\"\"\" pass","title":"webhook()"},{"location":"api.html#daschat_base.dc_abc_handoff.WebhookTypesEnum","text":"An enumeration.","title":"WebhookTypesEnum"},{"location":"api.html#daschat_base.schemas","text":"Daschat base schemas.","title":"schemas"},{"location":"api.html#daschat_base.schemas.ActionToTypeEnum","text":"ActionToTypeEnum Actions types.","title":"ActionToTypeEnum"},{"location":"api.html#daschat_base.schemas.Chat","text":"","title":"Chat"},{"location":"api.html#daschat_base.schemas.Chat.channel","text":"Channel used by this chat.","title":"channel"},{"location":"api.html#daschat_base.schemas.Chat.channel_config","text":"Channel config key.","title":"channel_config"},{"location":"api.html#daschat_base.schemas.Chat.channel_contact_uid","text":"Channel contact UID.","title":"channel_contact_uid"},{"location":"api.html#daschat_base.schemas.Chat.channel_plugin","text":"Channel plugin used by this chat.","title":"channel_plugin"},{"location":"api.html#daschat_base.schemas.Chat.channel_uid","text":"Contact from UID.","title":"channel_uid"},{"location":"api.html#daschat_base.schemas.Chat.contact_id","text":"The contact ID this chat call.","title":"contact_id"},{"location":"api.html#daschat_base.schemas.Chat.handsoff_cid","text":"Handsoff app own chat ID","title":"handsoff_cid"},{"location":"api.html#daschat_base.schemas.Chat.handsoff_data","text":"handsoff data received from the plugin and that need to be stored.","title":"handsoff_data"},{"location":"api.html#daschat_base.schemas.Chat.handson","text":"Channel handson PLUGIN.","title":"handson"},{"location":"api.html#daschat_base.schemas.Chat.handson_config","text":"Channel handson config key.","title":"handson_config"},{"location":"api.html#daschat_base.schemas.Chat.id","text":"The ID of this chat.","title":"id"},{"location":"api.html#daschat_base.schemas.Chat.owner_id","text":"The ID of the owner of this chat.","title":"owner_id"},{"location":"api.html#daschat_base.schemas.Chat.status","text":"Chat status.","title":"status"},{"location":"api.html#daschat_base.schemas.Chat.subject","text":"Chat subject.","title":"subject"},{"location":"api.html#daschat_base.schemas.Config","text":"","title":"Config"},{"location":"api.html#daschat_base.schemas.Config.id","text":"The ID of the config.","title":"id"},{"location":"api.html#daschat_base.schemas.Config.key","text":"Config unique key.","title":"key"},{"location":"api.html#daschat_base.schemas.Config.label","text":"This config label.","title":"label"},{"location":"api.html#daschat_base.schemas.Config.owner_id","text":"The ID of the owner of this config.","title":"owner_id"},{"location":"api.html#daschat_base.schemas.Config.status","text":"Config status.","title":"status"},{"location":"api.html#daschat_base.schemas.Config.value","text":"Config value in json format.","title":"value"},{"location":"api.html#daschat_base.schemas.Contact","text":"","title":"Contact"},{"location":"api.html#daschat_base.schemas.Contact.channel","text":"Channel used by this contact.","title":"channel"},{"location":"api.html#daschat_base.schemas.Contact.channel_id","text":"Contact channel ID.","title":"channel_id"},{"location":"api.html#daschat_base.schemas.Contact.email","text":"Contact email.","title":"email"},{"location":"api.html#daschat_base.schemas.Contact.full_name","text":"Contact full name.","title":"full_name"},{"location":"api.html#daschat_base.schemas.Contact.id","text":"The ID of the Contact call.","title":"id"},{"location":"api.html#daschat_base.schemas.Contact.owner_id","text":"The ID of the owner of this Contact call.","title":"owner_id"},{"location":"api.html#daschat_base.schemas.Contact.profile","text":"Contact profile.","title":"profile"},{"location":"api.html#daschat_base.schemas.Contact.status","text":"Contact status.","title":"status"},{"location":"api.html#daschat_base.schemas.CustomFields","text":"","title":"CustomFields"},{"location":"api.html#daschat_base.schemas.CustomFields.key","text":"Unique key.","title":"key"},{"location":"api.html#daschat_base.schemas.CustomFields.overwrite","text":"Overwrite existent value.","title":"overwrite"},{"location":"api.html#daschat_base.schemas.CustomFields.value","text":"Value of the key.","title":"value"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema","text":"","title":"HandsoffDataSchema"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema.key","text":"Data unique key.","title":"key"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema.namespace","text":"Which plugin this data belongs to.","title":"namespace"},{"location":"api.html#daschat_base.schemas.HandsoffDataSchema.value","text":"Data value in json format.","title":"value"},{"location":"api.html#daschat_base.schemas.MediaMetaData","text":"","title":"MediaMetaData"},{"location":"api.html#daschat_base.schemas.MediaMetaData.height","text":"Height for image media.","title":"height"},{"location":"api.html#daschat_base.schemas.MediaMetaData.name","text":"Original media file name.","title":"name"},{"location":"api.html#daschat_base.schemas.MediaMetaData.path","text":"The valid absolute path of the media in the storage system","title":"path"},{"location":"api.html#daschat_base.schemas.MediaMetaData.src","text":"The valid absolute URL of the media. Needs to be HTTPS","title":"src"},{"location":"api.html#daschat_base.schemas.MediaMetaData.type","text":"Media type.","title":"type"},{"location":"api.html#daschat_base.schemas.MediaMetaData.uid","text":"Media optional UID.","title":"uid"},{"location":"api.html#daschat_base.schemas.MediaMetaData.width","text":"Width for image media.","title":"width"},{"location":"api.html#daschat_base.schemas.MessageSchema","text":"","title":"MessageSchema"},{"location":"api.html#daschat_base.schemas.MessageSchema.content","text":"Message content.","title":"content"},{"location":"api.html#daschat_base.schemas.MessageSchema.message_type","text":"Message type.","title":"message_type"},{"location":"api.html#daschat_base.schemas.MessageTypeEnum","text":"An enumeration.","title":"MessageTypeEnum"},{"location":"api.html#daschat_base.schemas.StateItemSchema","text":"","title":"StateItemSchema"},{"location":"api.html#daschat_base.schemas.StateItemSchema.data","text":"State saved data.","title":"data"},{"location":"api.html#daschat_base.schemas.StateItemSchema.id","text":"State ID value.","title":"id"},{"location":"api.html#daschat_base.schemas.StateItemSchema.order","text":"Order in wich the plugin was executed.","title":"order"},{"location":"api.html#daschat_base.schemas.StateItemSchema.state","text":"Current state value.","title":"state"},{"location":"authors.html","text":"Credits \u00b6 Development Lead \u00b6 Abner G Jacobsen abner@apoana.com.br Contributors \u00b6 None yet. Why not be the first?","title":"authors"},{"location":"authors.html#credits","text":"","title":"Credits"},{"location":"authors.html#development-lead","text":"Abner G Jacobsen abner@apoana.com.br","title":"Development Lead"},{"location":"authors.html#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing.html","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/daschat-io/daschat_base/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Base package for the development of integration modules with chat applications for the handsoff of conversations. could always use more documentation, whether as part of the official Base package for the development of integration modules with chat applications for the handsoff of conversations. docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/daschat-io/daschat_base/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up daschat_base for local development. Fork the daschat_base repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/daschat_base.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/daschat-io/daschat_base/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_daschat_base ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes for version are committed in pyproject.toml and test_daschat_handsoff_base.py (including an entry in HISTORY.md). Then run: 1 2 3 $ git tag v0.7.0 $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing.html#report-bugs","text":"Report bugs at https://github.com/daschat-io/daschat_base/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing.html#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing.html#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing.html#write-documentation","text":"Base package for the development of integration modules with chat applications for the handsoff of conversations. could always use more documentation, whether as part of the official Base package for the development of integration modules with chat applications for the handsoff of conversations. docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing.html#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/daschat-io/daschat_base/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up daschat_base for local development. Fork the daschat_base repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/daschat_base.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/daschat-io/daschat_base/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing.html#tips","text":"1 $ pytest tests.test_daschat_base ```To run a subset of tests.","title":"Tips```"},{"location":"contributing.html#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes for version are committed in pyproject.toml and test_daschat_handsoff_base.py (including an entry in HISTORY.md). Then run: 1 2 3 $ git tag v0.7.0 $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history.html","text":"History \u00b6 0.9.0 (2021-10-05) \u00b6 Added columns for handsoff app data and chat id control 0.8.0 (2021-07-21) \u00b6 Added webhook enum type for CHAT_TAKEN Docs corrections in how to deploy official version 0.7.0 (2021-07-20) \u00b6 Added CHAT_SESSION as webhook type enum. 0.4.0 (2021-06-28) \u00b6 First release on PyPI.","title":"history"},{"location":"history.html#history","text":"","title":"History"},{"location":"history.html#090-2021-10-05","text":"Added columns for handsoff app data and chat id control","title":"0.9.0 (2021-10-05)"},{"location":"history.html#080-2021-07-21","text":"Added webhook enum type for CHAT_TAKEN Docs corrections in how to deploy official version","title":"0.8.0 (2021-07-21)"},{"location":"history.html#070-2021-07-20","text":"Added CHAT_SESSION as webhook type enum.","title":"0.7.0 (2021-07-20)"},{"location":"history.html#040-2021-06-28","text":"First release on PyPI.","title":"0.4.0 (2021-06-28)"},{"location":"installation.html","text":"Installation \u00b6 Stable release \u00b6 To install Base package for the development of integration modules with chat applications for the handsoff of conversations., run this command in your terminal: 1 $ pip install daschat_base This is the preferred method to install Base package for the development of integration modules with chat applications for the handsoff of conversations., as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Base package for the development of integration modules with chat applications for the handsoff of conversations. can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/daschat-io/daschat_base Or download the tarball : 1 $ curl -OJL https://github.com/daschat-io/daschat_base/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"installation"},{"location":"installation.html#installation","text":"","title":"Installation"},{"location":"installation.html#stable-release","text":"To install Base package for the development of integration modules with chat applications for the handsoff of conversations., run this command in your terminal: 1 $ pip install daschat_base This is the preferred method to install Base package for the development of integration modules with chat applications for the handsoff of conversations., as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation.html#from-source","text":"The source for Base package for the development of integration modules with chat applications for the handsoff of conversations. can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/daschat-io/daschat_base Or download the tarball : 1 $ curl -OJL https://github.com/daschat-io/daschat_base/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage.html","text":"Usage \u00b6 To use Base package for the development of integration modules with chat applications for the handsoff of conversations. in a project 1 from daschat_base imports schemas","title":"usage"},{"location":"usage.html#usage","text":"To use Base package for the development of integration modules with chat applications for the handsoff of conversations. in a project 1 from daschat_base imports schemas","title":"Usage"}]}